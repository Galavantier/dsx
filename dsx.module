<?php
/**
 * @file dsx.module
 * The core of DSX: Drupal Syntax Extension.
 * Inspired by Facebooks' JSX and XHP projects,
 * The module takes XML/HTML strings and converts them into Drupal Render Arrays.
 * DSX supports XML namespaces,
 * 							the full Drupal form API,
 * 							and is extensible via dynamic hooks for custom XML tags,
 *        			Or via the more traditional hook_element_info().
 */

module_load_include('inc', 'dsx', 'dsx.maps');

/**
 * The main render function. Kicks off the DSX process.
 * This is the only function that should be called from user code directly.
 * It's main function is to parse the XML string into a Tree structure using simpleXML that is built into PHP.
 * @see: http://php.net/manual/en/class.simplexmlelement.php
 *
 * dsx_render then passes the tree structure into dsx_to_array,
 * a recursive visitor function that walks the tree and produces a Drupal render array.
 *
 * @param  string | array  $input  An XML formatted string, or an array of XML formatted strings.
 * @return array                   A drupal render array. @see: https://www.drupal.org/node/930760
 */
function dsx_render($input) {
  // If $input is an array
  if(is_array($input)) {
    return array_map(function($element) { return dsx_render($element); }, $input);
  }
  // simpleXML does not support HTML special chars, or the '&' character directly.
  // We convert to UTF-8 Decimal encoding, which simpleXML does understand.
  $input = dsx_convert_html_special_chars($input);

  // Tell simpleXML that we will handle errors ourselves. This lets us be a bit more flexible.
  libxml_use_internal_errors(TRUE);
  try {
    // Parse the input into an XML tree.
    $xml = new SimpleXMLElement($input);
  } catch (Exception $e) {
    foreach(libxml_get_errors() as $error) {
      switch($error->code) {
        case 5:
          // We are missing a parent tag. Add a temporary one, then remove it and pass along the children.
          // This allows our components to output arbitrary lists of tags without having a parent tag.
          $element = dsx_to_array(new SimpleXMLElement('<div temp-container="true">' . $input . '</div>'), array(), dsx_strict_mode());
          return array_intersect_key($element, array_flip(element_children($element)));
        case 201:
          // We ignore 'undefined namespace' errors. There is no need to have to formally define a namespace with an xlnms attribute,
          // just start using the namespace.
          break;
        default:
        // Any other errors that we don't know how to handle, just spit out the screen.
        // @TODO: Do we want a watchdog error as well?
        drupal_set_message('DSX: Error code ' . $error->code . ', while attempting to parse input: ' . $input . $error->message, 'error');
        return "";
      }
    }
  }

  // Kick off the recursive function that walks the parsed tree to produce a Drupal render array.
  return dsx_to_array($xml, array(), dsx_strict_mode());
}

/**
 * This function acts as a sticky switch that tells DSX if strict mode is on off.
 * The value of strict mode is sticky only for the duration of one script execution.
 * It defaults to TRUE.
 *
 * If you pass a value into this function, it changes the value of strict mode.
 * Otherwise, if you don't pass anything, it just returns the current value of strict mode.
 *
 * @param  boolean $strict (OPTIONAL) A new value for strict mode.
 * @return boolean         Either the current value of strict mode, or the new value for strict mode that was just set.
 */
function dsx_strict_mode($strict = NULL) {
  $strict_mode = &drupal_static(__FUNCTION__);
  if(!isset($strict_mode)) { $strict_mode = TRUE; }
  if(isset($strict)) { $strict_mode = $strict; }
  return $strict_mode;
}

/**
 * A recursive visitor function, that visits each node of a simpleXML tree structure,
 * and produces a (hopefully) valid Drupal render array.
 *
 * @param SimpleXMLElement $xml   [description]
 * @param array $arr              [description]
 * @param boolean $strict         [description]
 * @return array                  [description]
 */
function dsx_to_array($xml,$arr, $strict = true) {
    $std_tags = dsx_std_html_tags();
    $tag = dsx_parse_qualified_name($xml->getName());

    $drupal_element_info = array();
    if ($tag->namespace == "drupal") {
      $drupal_element_info = element_info($tag->name);
    } else if( $tag->namespace != "global" ) {
      $drupal_element_info = element_info($tag->namespace . "_" . str_replace("-", "_", $tag->name));
    }

    if(sizeof($drupal_element_info) > 0 || in_array($tag->name, $std_tags)) {
      $arr = dsx_component_to_drupal_render_array($tag, $xml, $drupal_element_info);
    } else {
      $hook = str_replace("-", "_", $tag->name) . '_component';
      if($tag->namespace != "global") { $hook = $tag->namespace . "_" . $hook; }

      $modules = module_implements($hook);

      // module_implements does not check inside themes, so we check the active theme ourselves.
      global $theme_key;
      if(function_exists($theme_key . "_" . $hook)) { array_push($modules, $theme_key); }

      // Check for errors. There must be exactly one render function. no more, no less.
      if(sizeof($modules) < 1) {
        if($strict) {
          throw new Exception("DSX: the tag " . $xml->getName() . " must have a render function defined. The format is HOOK_" . $hook);
        } else  {
          // If we are not in strict mode and there are no render functions for this component,
          // just render the tag as it is.
          $arr = dsx_component_to_drupal_render_array($tag, $xml);
        }
      } else if(sizeof($modules) > 1) {
        throw new Exception("DSX: the tag " . $xml->getName() . " must only have one render function defined." .
                            " The following modules have competing render functions: " . implode(', ', $modules));
      } else {
        // Call the render function for the custom component
        $function = $modules[0] . '_' . $hook;
        if (function_exists($function)) {
          $props = array();
          foreach($xml->attributes() as $attr => $val) {
              $props[$attr] = filter_xss(check_plain((string)$val));
          }
          // This is going to be a recurisve call 99.9% of the time.
          $arr = call_user_func_array(dsx_detect_infinite_recursion($function), array('props' => $props, 'value' => filter_xss(check_plain((string)$xml)) ));
        } else {
          throw new Exception("DSX: the render function for the tag " . $tag->name . " is not defined.");
        }
      }
    }

    $children = array();
    foreach($xml->children() as $child) {
      $rendered_child = dsx_to_array($child, array(), $strict);
      if(isset($child->attributes()->{'name'})) {
        $children[(string)$child->attributes()->{'name'}] = $rendered_child[(string)$child->attributes()->{'name'}];
      } else {
        $children[] = $rendered_child;
      }
    }
    $is_deep_embed_parent = (!isset($xml->attributes()->{'dsx-deep-embed'}) && isset($arr['#attributes']['dsx-deep-embed']));
    $arr = dsx_insert_children($arr, $children,  $is_deep_embed_parent);
    // We have to unset the deep embed attribute, so that it does not propogate up to any render functions higher in the tree, causing deep embed to run twice.
    if($is_deep_embed_parent) { unset($arr['#attributes']['dsx-deep-embed']); }

    if(isset($xml->attributes()->{'name'})) {
      return array( (string)$xml->attributes()->{'name'} => $arr);
    } else {
      return $arr;
    }
};

function dsx_insert_children($arr, $children, $bubble_down = false) {
  if($bubble_down) {
    $cur_children = element_children($arr);
    if(sizeof($cur_children) > 1) {
      throw new Exception("DSX: A component can only have one child for deep embedding of children: " . var_export($arr, TRUE));
    } else if(sizeof($cur_children) < 1) {
      return array_merge($arr, $children);
    } else {
      $arr[$cur_children[0]] = dsx_insert_children($arr[$cur_children[0]], $children, $bubble_down);
      return $arr;
    }
  } else {
    return array_merge($arr, $children);
  }
}

function dsx_component_to_drupal_render_array($tag, $xml, $element_info = array()) {
  $arr = array('#type' => 'html_tag', '#attributes' => array() );
  if(sizeof($element_info) < 1) {
    $arr['#tag'] = $tag->name;
    $arr['#value'] = filter_xss(check_plain((string)$xml));

    foreach($xml->attributes() as $attr => $val) {
        if ( $attr == 'class' ) {
          $filtered_val = filter_xss(check_plain((string)$val));
          $arr['#attributes'][$attr] = explode(' ', $filtered_val);
        } else {
          $arr['#attributes'][$attr] = filter_xss(check_plain((string)$val));
        }
    }
  } else {
    $arr['#type'] = $element_info['#type'];
    $val = filter_xss(check_plain(trim((string)$xml)));
    if(strlen($val) > 0) {
      $arr['#value'] = $val;
    }

    foreach($xml->attributes() as $attr => $val) {
      if($attr == 'attributes') {
        $arr['#attributes'] = array_merge($arr['#attributes'], json_decode(str_replace("'", '"',(string)$val), true));
      }else if ( $attr == 'class' ) {
        $filtered_val = filter_xss(check_plain((string)$val));
        $arr['#attributes'][$attr] = explode(' ', $filtered_val);
      } else if(in_array($attr, array('id', 'enctype', 'lang')) || strpos($attr, 'on') !== FALSE) {
        $filtered_val = filter_xss(check_plain((string)$val));
        $arr['#attributes'][$attr] = $filtered_val;
      } else {
        $filtered_val = filter_xss(check_plain((string)$val));
        $arr['#' . $attr] = $filtered_val;
      }
    }
  }

  return $arr;
}

function dsx_preprocess_html_tag(&$variables) {
  // Loop over element children, render them, and add them to the #value string.
  foreach (element_children($variables['element']) as $key) {
    if ($variables['element']['#value'] === NULL) {
      // Set this to string to avoid E_NOTICE error when concatenating to NULL.
      $variables['element']['#value'] = '';
    }
    // Concatenate the rendered child onto the element #value.
    $variables['element']['#value'] .= drupal_render($variables['element'][$key]);
  }
}

function dsx_parse_qualified_name($tagName) {
  $parts = explode(":", $tagName);
  $tag = new stdClass();

  if(sizeof($parts) < 1) {
    throw new Exception("DSX: Unable to parse tag name: " . $tagName);
  }
  if(sizeof($parts) < 2) {
    $tag->namespace = "global";
    $tag->name = $parts[0];
  } else {
    $tag->namespace = $parts[0];
    $tag->name = $parts[1];
  }
  return $tag;
}

/**
 * Detect if we are about to enter an infinite recursion.
 * This works by detecting if we are about to call a render function inside itself,
 * even if the call to itself is nested inside a sub-render-function.
 * In Computer Science speak we are checking for cycles in the call stack.
 *
 * This function relies the PHP debug_stacktrace function, which lets us examine the current call stack.
 * @see http://php.net/manual/en/function.debug-backtrace.php
 *
 * @param  string $function             The function name about to be called.
 * @return string | Exception           Either returns the function name, or throws an Exception.
 */
function dsx_detect_infinite_recursion($function) {
  // We only care about the function names.
  $stack_trace = array_map(function($stack_frame) { return $stack_frame['function']; }, debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS));

  // Is this function name already on the stack? If so, we have a cycle.
  $cycles = array_filter($stack_trace, function($stack_frame) use ($function) { return $stack_frame == $function; });
  if(sizeof($cycles) > 0) {
    // PHP gives us the stack with the last called function first, but it is more useful for debugging to see the stack in reverse order; first function called first.
    $stack_trace = array_reverse($stack_trace);
    // We add the function that was about to be called to the end of the stack trace, so that the cycle is obviously visible.
    $stack_trace[] = $function;

    // For debugging, We only care about DSX render functions, which all end in "_component". All other function calls are just noise.
    $render_functions_stack_trace = array_filter($stack_trace, function($stack_frame){ return strpos($stack_frame, '_component') !== FALSE; });
    throw new Exception("DSX: Infinite recursion detected. The following render function was called inside itself: " . $function
    . ".\t Stack Trace: " . implode(" -> ", $render_functions_stack_trace));
  }
  return $function;
}

/**
 * simpleXML does not support HTML named special character encoding, or the '&' character.
 * It only supports UTF-8 Decimal form of special character encoding.
 * I.E. &nbsp; will error, but &#160; works fine.
 * Surpisingly, a converter for HTML named entity to UTF-8 is not built into php.
 * PHP htmlspecialchars() or drupal check_plain() will not work because those functions will try to convert the
 * HTML tags as well.
 */
function dsx_convert_html_special_chars($input) {
  $entity_map = dsx_html_entity_map();
  $html_entities = array_keys($entity_map);
  $utf_entities = array_values($entity_map);
  $output = str_replace($html_entities, $utf_entities, $input);
  //Convert regular '&' character into the special char entity form.
  $output = preg_replace('/&(?!#[0-9]+;)/', '&#38;', $output);
  return $output;
}
