<?php

/**
 * @file dsx.module
 * The core of DSX: Drupal Syntax Extension.
 * Inspired by Facebooks' JSX and XHP projects,
 * The module takes XML/HTML strings and converts them into Drupal Render Arrays.
 * DSX supports XML namespaces,
 * 							the full Drupal form API,
 * 							and is extensible via dynamic hooks for custom XML tags,
 *        			Or via the more traditional hook_element_info().
 */

function dsx_render($input) {
  if(is_array($input)) {
    return array_map(function($element) { return dsx_render($element); }, $input);
  }
  // simpleXML does not support HTML special chars, or the '&' character directly.
  // We convert to UTF-8 Decimal encoding, which simpleXML does understand.
  $input = dsx_convert_html_special_chars($input);
  libxml_use_internal_errors(TRUE);
  try {
    $xml = new SimpleXMLElement($input);
  } catch (Exception $e) {
    foreach(libxml_get_errors() as $error) {
      switch($error->code) {
        case 5:
          // We are missing a parent tag. Add a temporary one, then remove it and pass along the children.
          // This allows our components to output arbitrary lists of tags without having a parent tag.
          $element = dsx_to_array(new SimpleXMLElement('<div temp-container="true">' . $input . '</div>'), array(), dsx_strict_mode());
          return array_intersect_key($element, array_flip(element_children($element)));
        case 201:
          break;
        default:
        drupal_set_message('DSX: Error code ' . $error->code . ', while attempting to parse input: ' . $input . $error->message, 'error');
        return "";
      }
    }
  }
  return dsx_to_array($xml, array(), dsx_strict_mode());
}

function dsx_strict_mode($strict = NULL) {
  $strict_mode = &drupal_static(__FUNCTION__);
  if(!isset($strict_mode)) { $strict_mode = TRUE; }
  if(isset($strict)) { $strict_mode = $strict; }
  return $strict_mode;
}

function dsx_to_array($xml,$arr, $strict = true) {
    $std_tags = dsx_std_html_tags();
    $tag = dsx_parse_qualified_name($xml->getName());

    $drupal_element_info = array();
    if ($tag->namespace == "drupal") {
      $drupal_element_info = element_info($tag->name);
    } else if( $tag->namespace != "global" ) {
      $drupal_element_info = element_info($tag->namespace . "_" . str_replace("-", "_", $tag->name));
    }

    if(sizeof($drupal_element_info) > 0 || in_array($tag->name, $std_tags)) {
      $arr = dsx_component_to_drupal_render_array($tag, $xml, $drupal_element_info);
    } else {
      $hook = str_replace("-", "_", $tag->name) . '_component';
      if($tag->namespace != "global") { $hook = $tag->namespace . "_" . $hook; }

      $modules = module_implements($hook);

      // module_implements does not check inside themes, so we check the active theme ourselves.
      global $theme_key;
      if(function_exists($theme_key . "_" . $hook)) { array_push($modules, $theme_key); }

      // Check for errors. There must be exactly one render function. no more, no less.
      if(sizeof($modules) < 1) {
        if($strict) {
          throw new Exception("DSX: the tag " . $xml->getName() . " must have a render function defined. The format is HOOK_" . $hook);
        } else  {
          // If we are not in strict mode and there are no render functions for this component,
          // just render the tag as it is.
          $arr = dsx_component_to_drupal_render_array($tag, $xml);
        }
      } else if(sizeof($modules) > 1) {
        throw new Exception("DSX: the tag " . $xml->getName() . " must only have one render function defined." .
                            " The following modules have competing render functions: " . implode(', ', $modules));
      } else {
        // Call the render function for the custom component
        $function = $modules[0] . '_' . $hook;
        if (function_exists($function)) {
          $props = array();
          foreach($xml->attributes() as $attr => $val) {
              $props[$attr] = filter_xss(check_plain((string)$val));
          }
          // This is going to be a recurisve call 99.9% of the time.
          $arr = call_user_func_array(dsx_detect_infinite_recursion($function), array('props' => $props, 'value' => filter_xss(check_plain((string)$xml)) ));
        } else {
          throw new Exception("DSX: the render function for the tag " . $tag->name . " is not defined.");
        }
      }
    }

    $children = array();
    foreach($xml->children() as $child) {
      $rendered_child = dsx_to_array($child, array(), $strict);
      if(isset($child->attributes()->{'name'})) {
        $children[(string)$child->attributes()->{'name'}] = $rendered_child[(string)$child->attributes()->{'name'}];
      } else {
        $children[] = $rendered_child;
      }
    }
    $is_deep_embed_parent = (!isset($xml->attributes()->{'dsx-deep-embed'}) && isset($arr['#attributes']['dsx-deep-embed']));
    $arr = dsx_insert_children($arr, $children,  $is_deep_embed_parent);
    // We have to unset the deep embed attribute, so that it does not propogate up to any render functions higher in the tree, causing deep embed to run twice.
    if($is_deep_embed_parent) { unset($arr['#attributes']['dsx-deep-embed']); }

    if(isset($xml->attributes()->{'name'})) {
      return array( (string)$xml->attributes()->{'name'} => $arr);
    } else {
      return $arr;
    }
};

function dsx_insert_children($arr, $children, $bubble_down = false) {
  if($bubble_down) {
    $cur_children = element_children($arr);
    if(sizeof($cur_children) > 1) {
      throw new Exception("DSX: A component can only have one child for deep embedding of children: " . var_export($arr, TRUE));
    } else if(sizeof($cur_children) < 1) {
      return array_merge($arr, $children);
    } else {
      $arr[$cur_children[0]] = dsx_insert_children($arr[$cur_children[0]], $children, $bubble_down);
      return $arr;
    }
  } else {
    return array_merge($arr, $children);
  }
}

function dsx_component_to_drupal_render_array($tag, $xml, $element_info = array()) {
  $arr = array('#type' => 'html_tag', '#attributes' => array() );
  if(sizeof($element_info) < 1) {
    $arr['#tag'] = $tag->name;
    $arr['#value'] = filter_xss(check_plain((string)$xml));

    foreach($xml->attributes() as $attr => $val) {
        if ( $attr == 'class' ) {
          $filtered_val = filter_xss(check_plain((string)$val));
          $arr['#attributes'][$attr] = explode(' ', $filtered_val);
        } else {
          $arr['#attributes'][$attr] = filter_xss(check_plain((string)$val));
        }
    }
  } else {
    $arr['#type'] = $element_info['#type'];
    $val = filter_xss(check_plain(trim((string)$xml)));
    if(strlen($val) > 0) {
      $arr['#value'] = $val;
    }

    foreach($xml->attributes() as $attr => $val) {
      if($attr == 'attributes') {
        $arr['#attributes'] = array_merge($arr['#attributes'], json_decode(str_replace("'", '"',(string)$val), true));
      }else if ( $attr == 'class' ) {
        $filtered_val = filter_xss(check_plain((string)$val));
        $arr['#attributes'][$attr] = explode(' ', $filtered_val);
      } else if(in_array($attr, array('id', 'enctype', 'lang')) || strpos($attr, 'on') !== FALSE) {
        $filtered_val = filter_xss(check_plain((string)$val));
        $arr['#attributes'][$attr] = $filtered_val;
      } else {
        $filtered_val = filter_xss(check_plain((string)$val));
        $arr['#' . $attr] = $filtered_val;
      }
    }
  }

  return $arr;
}

function dsx_preprocess_html_tag(&$variables) {
  // Loop over element children, render them, and add them to the #value string.
  foreach (element_children($variables['element']) as $key) {
    if ($variables['element']['#value'] === NULL) {
      // Set this to string to avoid E_NOTICE error when concatenating to NULL.
      $variables['element']['#value'] = '';
    }
    // Concatenate the rendered child onto the element #value.
    $variables['element']['#value'] .= drupal_render($variables['element'][$key]);
  }
}

function dsx_parse_qualified_name($tagName) {
  $parts = explode(":", $tagName);
  $tag = new stdClass();

  if(sizeof($parts) < 1) {
    throw new Exception("DSX: Unable to parse tag name: " . $tagName);
  }
  if(sizeof($parts) < 2) {
    $tag->namespace = "global";
    $tag->name = $parts[0];
  } else {
    $tag->namespace = $parts[0];
    $tag->name = $parts[1];
  }
  return $tag;
}

/**
 * Detect if we are about to enter an infinite recursion.
 * This works by detecting if we are about to call a render function inside itself,
 * even if the call to itself is nested inside a sub-render-function.
 * In Computer Science speak we are checking for cycles in the call stack.
 *
 * This function relies the PHP debug_stacktrace function, which lets us examine the current call stack.
 * @see http://php.net/manual/en/function.debug-backtrace.php
 *
 * @param  string $function             The function name about to be called.
 * @return string | Exception           Either returns the function name, or throws an Exception.
 */
function dsx_detect_infinite_recursion($function) {
  // We only care about the function names.
  $stack_trace = array_map(function($stack_frame) { return $stack_frame['function']; }, debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS));

  // Is this function name already on the stack? If so, we have a cycle.
  $cycles = array_filter($stack_trace, function($stack_frame) use ($function) { return $stack_frame == $function; });
  if(sizeof($cycles) > 0) {
    // PHP gives us the stack with the last called function first, but it is more useful for debugging to see the stack in reverse order; first function called first.
    $stack_trace = array_reverse($stack_trace);
    // We add the function that was about to be called to the end of the stack trace, so that the cycle is obviously visible.
    $stack_trace[] = $function;

    // For debugging, We only care about DSX render functions, which all end in "_component". All other function calls are just noise.
    $render_functions_stack_trace = array_filter($stack_trace, function($stack_frame){ return strpos($stack_frame, '_component') !== FALSE; });
    throw new Exception("DSX: Infinite recursion detected. The following render function was called inside itself: " . $function
    . ".\t Stack Trace: " . implode(" -> ", $render_functions_stack_trace));
  }
  return $function;
}

/**
 * simpleXML does not support HTML named special character encoding, or the '&' character.
 * It only supports UTF-8 Decimal form of special character encoding.
 * I.E. &nbsp; will error, but &#160; works fine.
 * Surpisingly a converter for HTML named entity to UTF-8 is not built into php.
 * PHP htmlspecialchars() or drupal check_plain() will not work because those functions will try to convert the
 * HTML tags as well.
 */
function dsx_convert_html_special_chars($input) {
  $entity_map = dsx_html_entity_map();
  $html_entities = array_keys($entity_map);
  $utf_entities = array_values($entity_map);
  $output = str_replace($html_entities, $utf_entities, $input);
  //Convert regular '&' character into the special char entity form.
  $output = preg_replace('/&($|<| )/', '&#38;${1}', $output);
  return $output;
}

function dsx_html_entity_map() {
  $map = array(
    "&amp;"      => "&#38;",
    "&lt;"       => "&#60;",
    "&gt;"       => "&#62;",
    "&nbsp;"     => "&#160;",
    "&iexcl;"    => "&#161;",
    "&cent;"     => "&#162;",
    "&pound;"    => "&#163;",
    "&curren;"   => "&#164;",
    "&yen;"      => "&#165;",
    "&brvbar;"   => "&#166;",
    "&sect;"     => "&#167;",
    "&uml;"      => "&#168;",
    "&copy;"     => "&#169;",
    "&ordf;"     => "&#170;",
    "&laquo;"    => "&#171;",
    "&not;"      => "&#172;",
    "&shy;"      => "&#173;",
    "&reg;"      => "&#174;",
    "&macr;"     => "&#175;",
    "&deg;"      => "&#176;",
    "&plusmn;"   => "&#177;",
    "&sup2;"     => "&#178;",
    "&sup3;"     => "&#179;",
    "&acute;"    => "&#180;",
    "&micro;"    => "&#181;",
    "&para;"     => "&#182;",
    "&middot;"   => "&#183;",
    "&cedil;"    => "&#184;",
    "&sup1;"     => "&#185;",
    "&ordm;"     => "&#186;",
    "&raquo;"    => "&#187;",
    "&frac14;"   => "&#188;",
    "&frac12;"   => "&#189;",
    "&frac34;"   => "&#190;",
    "&iquest;"   => "&#191;",
    "&Agrave;"   => "&#192;",
    "&Aacute;"   => "&#193;",
    "&Acirc;"    => "&#194;",
    "&Atilde;"   => "&#195;",
    "&Auml;"     => "&#196;",
    "&Aring;"    => "&#197;",
    "&AElig;"    => "&#198;",
    "&Ccedil;"   => "&#199;",
    "&Egrave;"   => "&#200;",
    "&Eacute;"   => "&#201;",
    "&Ecirc;"    => "&#202;",
    "&Euml;"     => "&#203;",
    "&Igrave;"   => "&#204;",
    "&Iacute;"   => "&#205;",
    "&Icirc;"    => "&#206;",
    "&Iuml;"     => "&#207;",
    "&ETH;"      => "&#208;",
    "&Ntilde;"   => "&#209;",
    "&Ograve;"   => "&#210;",
    "&Oacute;"   => "&#211;",
    "&Ocirc;"    => "&#212;",
    "&Otilde;"   => "&#213;",
    "&Ouml;"     => "&#214;",
    "&times;"    => "&#215;",
    "&Oslash;"   => "&#216;",
    "&Ugrave;"   => "&#217;",
    "&Uacute;"   => "&#218;",
    "&Ucirc;"    => "&#219;",
    "&Uuml;"     => "&#220;",
    "&Yacute;"   => "&#221;",
    "&THORN;"    => "&#222;",
    "&szlig;"    => "&#223;",
    "&agrave;"   => "&#224;",
    "&aacute;"   => "&#225;",
    "&acirc;"    => "&#226;",
    "&atilde;"   => "&#227;",
    "&auml;"     => "&#228;",
    "&aring;"    => "&#229;",
    "&aelig;"    => "&#230;",
    "&ccedil;"   => "&#231;",
    "&egrave;"   => "&#232;",
    "&eacute;"   => "&#233;",
    "&ecirc;"    => "&#234;",
    "&euml;"     => "&#235;",
    "&igrave;"   => "&#236;",
    "&iacute;"   => "&#237;",
    "&icirc;"    => "&#238;",
    "&iuml;"     => "&#239;",
    "&eth;"      => "&#240;",
    "&ntilde;"   => "&#241;",
    "&ograve;"   => "&#242;",
    "&oacute;"   => "&#243;",
    "&ocirc;"    => "&#244;",
    "&otilde;"   => "&#245;",
    "&ouml;"     => "&#246;",
    "&divide;"   => "&#247;",
    "&oslash;"   => "&#248;",
    "&ugrave;"   => "&#249;",
    "&uacute;"   => "&#250;",
    "&ucirc;"    => "&#251;",
    "&uuml;"     => "&#252;",
    "&yacute;"   => "&#253;",
    "&thorn;"    => "&#254;",
    "&yuml;"     => "&#255;",
    "&fnof;"     => "&#402;",
    "&Alpha;"    => "&#913;",
    "&Beta;"     => "&#914;",
    "&Gamma;"    => "&#915;",
    "&Delta;"    => "&#916;",
    "&Epsilon;"  => "&#917;",
    "&Zeta;"     => "&#918;",
    "&Eta;"      => "&#919;",
    "&Theta;"    => "&#920;",
    "&Iota;"     => "&#921;",
    "&Kappa;"    => "&#922;",
    "&Lambda;"   => "&#923;",
    "&Mu;"       => "&#924;",
    "&Nu;"       => "&#925;",
    "&Xi;"       => "&#926;",
    "&Omicron;"  => "&#927;",
    "&Pi;"       => "&#928;",
    "&Rho;"      => "&#929;",
    "&Sigma;"    => "&#931;",
    "&Tau;"      => "&#932;",
    "&Upsilon;"  => "&#933;",
    "&Phi;"      => "&#934;",
    "&Chi;"      => "&#935;",
    "&Psi;"      => "&#936;",
    "&Omega;"    => "&#937;",
    "&alpha;"    => "&#945;",
    "&beta;"     => "&#946;",
    "&gamma;"    => "&#947;",
    "&delta;"    => "&#948;",
    "&epsilon;"  => "&#949;",
    "&zeta;"     => "&#950;",
    "&eta;"      => "&#951;",
    "&theta;"    => "&#952;",
    "&iota;"     => "&#953;",
    "&kappa;"    => "&#954;",
    "&lambda;"   => "&#955;",
    "&mu;"       => "&#956;",
    "&nu;"       => "&#957;",
    "&xi;"       => "&#958;",
    "&omicron;"  => "&#959;",
    "&pi;"       => "&#960;",
    "&rho;"      => "&#961;",
    "&sigmaf;"   => "&#962;",
    "&sigma;"    => "&#963;",
    "&tau;"      => "&#964;",
    "&upsilon;"  => "&#965;",
    "&phi;"      => "&#966;",
    "&chi;"      => "&#967;",
    "&psi;"      => "&#968;",
    "&omega;"    => "&#969;",
    "&thetasym;" => "&#977;",
    "&upsih;"    => "&#978;",
    "&piv;"      => "&#982;",
    "&bull;"     => "&#8226;",
    "&hellip;"   => "&#8230;",
    "&prime;"    => "&#8242;",
    "&Prime;"    => "&#8243;",
    "&oline;"    => "&#8254;",
    "&frasl;"    => "&#8260;",
    "&weierp;"   => "&#8472;",
    "&image;"    => "&#8465;",
    "&real;"     => "&#8476;",
    "&trade;"    => "&#8482;",
    "&alefsym;"  => "&#8501;",
    "&larr;"     => "&#8592;",
    "&uarr;"     => "&#8593;",
    "&rarr;"     => "&#8594;",
    "&darr;"     => "&#8595;",
    "&harr;"     => "&#8596;",
    "&crarr;"    => "&#8629;",
    "&lArr;"     => "&#8656;",
    "&uArr;"     => "&#8657;",
    "&rArr;"     => "&#8658;",
    "&dArr;"     => "&#8659;",
    "&hArr;"     => "&#8660;",
    "&forall;"   => "&#8704;",
    "&part;"     => "&#8706;",
    "&exist;"    => "&#8707;",
    "&empty;"    => "&#8709;",
    "&nabla;"    => "&#8711;",
    "&isin;"     => "&#8712;",
    "&notin;"    => "&#8713;",
    "&ni;"       => "&#8715;",
    "&prod;"     => "&#8719;",
    "&sum;"      => "&#8721;",
    "&minus;"    => "&#8722;",
    "&lowast;"   => "&#8727;",
    "&radic;"    => "&#8730;",
    "&prop;"     => "&#8733;",
    "&infin;"    => "&#8734;",
    "&ang;"      => "&#8736;",
    "&and;"      => "&#8743;",
    "&or;"       => "&#8744;",
    "&cap;"      => "&#8745;",
    "&cup;"      => "&#8746;",
    "&int;"      => "&#8747;",
    "&there4;"   => "&#8756;",
    "&sim;"      => "&#8764;",
    "&cong;"     => "&#8773;",
    "&asymp;"    => "&#8776;",
    "&ne;"       => "&#8800;",
    "&equiv;"    => "&#8801;",
    "&le;"       => "&#8804;",
    "&ge;"       => "&#8805;",
    "&sub;"      => "&#8834;",
    "&sup;"      => "&#8835;",
    "&nsub;"     => "&#8836;",
    "&sube;"     => "&#8838;",
    "&supe;"     => "&#8839;",
    "&oplus;"    => "&#8853;",
    "&otimes;"   => "&#8855;",
    "&perp;"     => "&#8869;",
    "&sdot;"     => "&#8901;",
    "&lceil;"    => "&#8968;",
    "&rceil;"    => "&#8969;",
    "&lfloor;"   => "&#8970;",
    "&rfloor;"   => "&#8971;",
    "&lang;"     => "&#9001;",
    "&rang;"     => "&#9002;",
    "&loz;"      => "&#9674;",
    "&spades;"   => "&#9824;",
    "&clubs;"    => "&#9827;",
    "&hearts;"   => "&#9829;",
    "&diams;"    => "&#9830;"
  );
  return $map;
}

function dsx_std_html_tags() {
  $tags = array(
    "html",
    "base",
    "head",
    "link",
    "meta",
    "script",
    "style",
    "title",
    "address",
    "article",
    "body",
    "h1",
    "h6",
    "footer",
    "aside",
    "nav",
    "section",
    "blockquote",
    "details",
    "fieldset",
    "figure",
    "td",
    "header",
    "h2",
    "h3",
    "h4",
    "h5",
    "hgroup",
    "cite",
    "dd",
    "dl",
    "dt",
    "div",
    "figcaption",
    ",",
    "hr",
    "li",
    "ol",
    "ul",
    "menu",
    "main",
    "list-style-type",
    "p",
    "pre",
    "a",
    "abbr",
    "b",
    "bdi",
    "bdo",
    "br",
    "code",
    "data",
    "time",
    "dfn",
    "em",
    "i",
    "kbd",
    "mark",
    "q",
    "rp",
    "ruby",
    "rt",
    "s",
    "del",
    "ins",
    "samp",
    "small",
    "span",
    "class",
    "id",
    "lang",
    "strong",
    "sub",
    "sup",
    "u",
    "var",
    "wbr",
    "area",
    "map",
    "audio",
    "src",
    "source",
    "img",
    "track",
    "video",
    "embed",
    "iframe",
    "frame-set",
    "object",
    "param",
    "picture",
    "canvas",
    "noscript",
    "del ",
    "caption",
    "table",
    "col",
    "colgroup",
    "tbody",
    "tr",
    "tfoot",
    "thead",
    "th",
    "scope",
    "headers",
    "button",
    "datalist",
    "option",
    "label",
    "form",
    "input",
    "type",
    "keygen",
    "for",
    "legend",
    "meter",
    "optgroup",
    "select",
    "output",
    "progress",
    "textarea",
    "textarea ",
    "details ",
    "dialog",
    "method=\"dialog\"",
    "returnValue",
    "value",
    "menuitem",
    "summary",
    "content",
    "decorator",
    "element",
    "shadow",
    "template",
    "acronym",
    "acronym)",
    "applet",
    "basefont",
    "font",
    "big",
    "blink",
    "center",
    "text-align",
    "dir",
    "frame",
    "frameset",
    "isindex",
    "listing",
    "noembed",
    "plaintext",
    "spacer",
    "spacer ",
    "strike",
    "tt",
    "xmp"
  );
  return $tags;
}
